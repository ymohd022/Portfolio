name: CI/CD for Portfolio

on:
  push:
    branches:
      - main

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v2

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v2

    - name: Login to DockerHub
      run: echo "${{ secrets.DOCKER_PASSWORD }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin

    - name: Build & Push Frontend
      id: build-frontend
      run: |
        docker build -t ${{ secrets.DOCKER_USERNAME }}/portfolio-frontend:latest ./Portfolio-Mohd_Yousuf
        docker push ${{ secrets.DOCKER_USERNAME }}/portfolio-frontend:latest
        echo "Frontend build completed successfully"

    - name: Build & Push Backend
      id: build-backend
      run: |
        docker build -t ${{ secrets.DOCKER_USERNAME }}/portfolio-backend:latest ./Backend
        docker push ${{ secrets.DOCKER_USERNAME }}/portfolio-backend:latest
        echo "Backend build completed successfully"

    - name: Deploy to EC2 Minikube and Setup Monitoring
      id: deploy-all
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.EC2_HOST }}
        username: ${{ secrets.EC2_USER }}
        key: ${{ secrets.EC2_KEY }}
        script: |
          set -e
          rm -rf Portfolio || true
          git clone https://github.com/ymohd022/Portfolio.git
          cd Portfolio/k8s
          
          # Deploy portfolio applications
          kubectl apply -f frontend-deployment.yaml
          kubectl apply -f frontend-service.yaml
          kubectl apply -f backend-deployment.yaml
          kubectl apply -f backend-service.yaml
          echo "Portfolio applications deployed successfully"
          
          # Deploy Prometheus monitoring
          echo "ðŸš€ Setting up Prometheus monitoring..."
          kubectl apply -f prometheus-deployment.yaml
          kubectl apply -f prometheus-configmap.yaml
          kubectl apply -f prometheus-service.yaml
          
          # Wait for Prometheus to be ready
          echo "â³ Waiting for Prometheus to be ready..."
          kubectl wait --for=condition=available --timeout=300s deployment/prometheus -n monitoring || true
          
          # Deploy Skooner for monitoring
          echo "ðŸš€ Setting up Skooner monitoring..."
          kubectl apply -f skooner-deployment.yaml
          kubectl apply -f skooner-configmap.yaml
          kubectl apply -f skooner-service.yaml
          
          # Wait for Skooner to be ready
          echo "â³ Waiting for Skooner to be ready..."
          kubectl wait --for=condition=available --timeout=300s deployment/skooner -n skooner || true
          
          # Get service information
          PROMETHEUS_NODEPORT=$(kubectl get svc prometheus-service -n monitoring -o jsonpath='{.spec.ports[0].nodePort}' 2>/dev/null || echo "30000")
          SKOONER_NODEPORT=$(kubectl get svc skooner-service -n skooner -o jsonpath='{.spec.ports[0].nodePort}' 2>/dev/null || echo "30123")
          PUBLIC_IP=$(curl -s http://169.254.169.254/latest/meta-data/public-ipv4 || echo "localhost")
          
          # Generate access tokens
          SKOONER_TOKEN=$(kubectl create token skooner-sa -n skooner --duration=8760h 2>/dev/null || echo "Token generation failed")
          
          echo "ðŸŽ‰ Deployment completed with monitoring!"
          echo "ðŸ“Š Prometheus: http://${PUBLIC_IP}:${PROMETHEUS_NODEPORT}"
          echo "ðŸ“Š Skooner Dashboard: http://${PUBLIC_IP}:${SKOONER_NODEPORT}"
          echo "ðŸ” Skooner Access Token: ${SKOONER_TOKEN}"
          
          # Display all services
          echo "ðŸ“‹ All deployed services:"
          kubectl get svc --all-namespaces
          
          # Setup Grafana Dashboard
          PROMETHEUS_URL="http://${PUBLIC_IP}:${PROMETHEUS_NODEPORT}"
          GRAFANA_URL="https://mohdyousuf9059.grafana.net"
          GRAFANA_API_KEY="${{ secrets.GRAFANA_API_KEY }}"
          
          echo "ðŸš€ Setting up Grafana Dashboard..."
          
          # Create Grafana data source
          cat > datasource.json << DSEOF
          {
            "name": "Portfolio-Prometheus",
            "type": "prometheus",
            "url": "${PROMETHEUS_URL}",
            "access": "proxy",
            "isDefault": true,
            "basicAuth": false,
            "jsonData": {
              "httpMethod": "POST",
              "manageAlerts": true,
              "prometheusType": "Prometheus",
              "prometheusVersion": "2.40.0"
            }
          }
          DSEOF
          
          # Try to create data source
          DS_RESPONSE=$(curl -s -X POST \
            -H "Authorization: Bearer ${GRAFANA_API_KEY}" \
            -H "Content-Type: application/json" \
            -d @datasource.json \
            "${GRAFANA_URL}/api/datasources" || echo "Data source creation failed")
          
          echo "ðŸ“Š Data source response: ${DS_RESPONSE}"
          
          # Get data source UID
          EXISTING_DS=$(curl -s -X GET \
            -H "Authorization: Bearer ${GRAFANA_API_KEY}" \
            -H "Content-Type: application/json" \
            "${GRAFANA_URL}/api/datasources")
          
          DATASOURCE_UID=$(echo "${EXISTING_DS}" | grep -o '"uid":"[^"]*".*"name":"Portfolio-Prometheus"' | cut -d'"' -f4 | head -1 || echo "portfolio-prometheus")
          
          echo "ðŸ“ˆ Using data source UID: ${DATASOURCE_UID}"
          
          # Create Portfolio Dashboard
          cat > dashboard.json << DASHEOF
          {
            "dashboard": {
              "id": null,
              "title": "Portfolio Application Monitoring",
              "tags": ["portfolio", "kubernetes", "monitoring"],
              "timezone": "browser",
              "panels": [
                {
                  "id": 1,
                  "title": "Application Uptime",
                  "type": "stat",
                  "targets": [
                    {
                      "expr": "up{job=~\"portfolio-.*|prometheus\"}",
                      "refId": "A",
                      "datasource": {
                        "type": "prometheus",
                        "uid": "${DATASOURCE_UID}"
                      }
                    }
                  ],
                  "gridPos": {"h": 8, "w": 12, "x": 0, "y": 0}
                },
                {
                  "id": 2,
                  "title": "HTTP Requests Rate",
                  "type": "timeseries",
                  "targets": [
                    {
                      "expr": "rate(prometheus_http_requests_total[5m])",
                      "refId": "A",
                      "datasource": {
                        "type": "prometheus",
                        "uid": "${DATASOURCE_UID}"
                      }
                    }
                  ],
                  "gridPos": {"h": 8, "w": 12, "x": 12, "y": 0}
                }
              ],
              "time": {"from": "now-1h", "to": "now"},
              "refresh": "30s",
              "schemaVersion": 39,
              "version": 0
            },
            "overwrite": true
          }
          DASHEOF
          
          # Create dashboard
          DASHBOARD_RESPONSE=$(curl -s -X POST \
            -H "Authorization: Bearer ${GRAFANA_API_KEY}" \
            -H "Content-Type: application/json" \
            -d @dashboard.json \
            "${GRAFANA_URL}/api/dashboards/db")
          
          echo "ðŸ“Š Dashboard response: ${DASHBOARD_RESPONSE}"
          
          DASHBOARD_URL=$(echo "${DASHBOARD_RESPONSE}" | grep -o '"url":"[^"]*"' | cut -d'"' -f4 | head -1)
          if [ -n "${DASHBOARD_URL}" ]; then
              echo "âœ… Portfolio Dashboard created successfully!"
              echo "ðŸ”— Dashboard URL: ${GRAFANA_URL}${DASHBOARD_URL}"
          fi
          
          echo "ðŸŽ‰ Grafana setup completed!"
          
          # Configure AWS and send notification
          export AWS_ACCESS_KEY_ID="${{ secrets.AWS_ACCESS_KEY_ID }}"
          export AWS_SECRET_ACCESS_KEY="${{ secrets.AWS_SECRET_ACCESS_KEY }}"
          export AWS_DEFAULT_REGION="${{ secrets.AWS_REGION }}"
          
          # Create success notification payload
          cat > success_payload.json << SUCCESSEOF
          {
            "repository": "${{ github.repository }}",
            "commit_sha": "${{ github.sha }}",
            "branch": "${{ github.ref_name }}",
            "build_status": "success",
            "workflow_run_id": "${{ github.run_id }}",
            "actor": "${{ github.actor }}",
            "prometheus_url": "${PROMETHEUS_URL}",
            "public_ip": "${PUBLIC_IP}",
            "grafana_url": "${GRAFANA_URL}"
          }
          SUCCESSEOF
          
          # Send success notification
          aws lambda invoke \
            --function-name portfolio-notification-lambda \
            --payload file://success_payload.json \
            --cli-binary-format raw-in-base64-out \
            success_response.json || echo "Lambda notification failed"
          
          echo "âœ… Success notification sent"
          [ -f success_response.json ] && cat success_response.json
          
          # Cleanup temporary files
          rm -f datasource.json dashboard.json success_payload.json success_response.json

    # Configure AWS credentials (fallback)
    - name: Configure AWS credentials
      if: failure()
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_REGION }}

    # Send failure notification via Lambda (if any step fails)
    - name: Send Failure Notification
      if: failure()
      run: |
        # Create payload file
        cat > failure_payload.json << EOF
        {
          "repository": "${{ github.repository }}",
          "commit_sha": "${{ github.sha }}",
          "branch": "${{ github.ref_name }}",
          "build_status": "failure",
          "workflow_run_id": "${{ github.run_id }}",
          "actor": "${{ github.actor }}"
        }
        EOF
        
        # Send failure notification
        aws lambda invoke \
          --function-name portfolio-notification-lambda \
          --payload file://failure_payload.json \
          --cli-binary-format raw-in-base64-out \
          failure_response.json || echo "Lambda notification failed"
        
        echo "Failure notification sent"
        [ -f failure_response.json ] && cat failure_response.json
