name: CI/CD for Portfolio

on:
  push:
    branches:
      - main

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v2

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v2

    - name: Login to DockerHub
      run: echo "${{ secrets.DOCKER_PASSWORD }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin

    - name: Build & Push Frontend
      id: build-frontend
      run: |
        docker build -t ${{ secrets.DOCKER_USERNAME }}/portfolio-frontend:latest ./Portfolio-Mohd_Yousuf
        docker push ${{ secrets.DOCKER_USERNAME }}/portfolio-frontend:latest
        echo "Frontend build completed successfully"

    - name: Build & Push Backend
      id: build-backend
      run: |
        docker build -t ${{ secrets.DOCKER_USERNAME }}/portfolio-backend:latest ./Backend
        docker push ${{ secrets.DOCKER_USERNAME }}/portfolio-backend:latest
        echo "Backend build completed successfully"

    - name: Deploy to EC2 Minikube
      id: deploy-k8s
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.EC2_HOST }}
        username: ${{ secrets.EC2_USER }}
        key: ${{ secrets.EC2_KEY }}
        script: |
          rm -rf Portfolio || true
          git clone https://github.com/ymohd022/Portfolio.git
          cd Portfolio/k8s
          
          # Deploy portfolio applications
          kubectl apply -f frontend-deployment.yaml
          kubectl apply -f frontend-service.yaml
          kubectl apply -f backend-deployment.yaml
          kubectl apply -f backend-service.yaml
          echo "Portfolio applications deployed successfully"
          
          # Deploy Prometheus monitoring
          echo "🚀 Setting up Prometheus monitoring..."
          kubectl apply -f prometheus-deployment.yaml
          kubectl apply -f prometheus-configmap.yaml
          kubectl apply -f prometheus-service.yaml
          
          # Wait for Prometheus to be ready
          echo "⏳ Waiting for Prometheus to be ready..."
          kubectl wait --for=condition=available --timeout=300s deployment/prometheus -n monitoring || true
          
          # Deploy Skooner for monitoring
          echo "🚀 Setting up Skooner monitoring..."
          kubectl apply -f skooner-deployment.yaml
          kubectl apply -f skooner-service.yaml
          kubectl apply -f skooner-configmap.yaml
          
          # Wait for Skooner to be ready
          echo "⏳ Waiting for Skooner to be ready..."
          kubectl wait --for=condition=available --timeout=300s deployment/skooner -n skooner || true
          
          # Get service information
          PROMETHEUS_NODEPORT=$(kubectl get svc prometheus-service -n monitoring -o jsonpath='{.spec.ports[0].nodePort}' 2>/dev/null || echo "30000")
          SKOONER_NODEPORT=$(kubectl get svc skooner-service -n skooner -o jsonpath='{.spec.ports[0].nodePort}' 2>/dev/null || echo "30123")
          PUBLIC_IP=$(curl -s http://169.254.169.254/latest/meta-data/public-ipv4)
          
          # Generate access tokens (with better error handling)
          echo "🔐 Generating Skooner access token..."
          SKOONER_TOKEN=""
          for i in {1..5}; do
            SKOONER_TOKEN=$(kubectl create token skooner-sa -n skooner --duration=8760h 2>/dev/null || echo "")
            if [ ! -z "$SKOONER_TOKEN" ]; then
              break
            fi
            echo "Attempt $i failed, retrying in 10 seconds..."
            sleep 10
          done
          
          if [ -z "$SKOONER_TOKEN" ]; then
            echo "⚠️  Token generation failed, trying alternative method..."
            SKOONER_TOKEN=$(kubectl get secret skooner-sa-token -n skooner -o jsonpath='{.data.token}' 2>/dev/null | base64 -d || echo "Manual token required")
          fi
          
          echo "🎉 Deployment completed with monitoring!"
          echo "📊 Prometheus: http://$PUBLIC_IP:$PROMETHEUS_NODEPORT"
          echo "📊 Skooner Dashboard: http://$PUBLIC_IP:$SKOONER_NODEPORT"
          echo "🔐 Skooner Access Token: $SKOONER_TOKEN"
          
          # Display all services
          echo "📋 All deployed services:"
          kubectl get svc --all-namespaces
          
          # Set environment variables for next steps
          echo "PROMETHEUS_URL=http://$PUBLIC_IP:$PROMETHEUS_NODEPORT" >> /tmp/env_vars
          echo "PUBLIC_IP=$PUBLIC_IP" >> /tmp/env_vars
          echo "SKOONER_TOKEN=$SKOONER_TOKEN" >> /tmp/env_vars
          
          # Display the environment variables
          cat /tmp/env_vars

    - name: Get Environment Variables
      id: get-env
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.EC2_HOST }}
        username: ${{ secrets.EC2_USER }}
        key: ${{ secrets.EC2_KEY }}
        script: |
          if [ -f /tmp/env_vars ]; then
            cat /tmp/env_vars
          else
            echo "PROMETHEUS_URL=http://$(curl -s http://169.254.169.254/latest/meta-data/public-ipv4):30000"
            echo "PUBLIC_IP=$(curl -s http://169.254.169.254/latest/meta-data/public-ipv4)"
          fi

    # Setup Grafana Dashboard
    - name: Setup Grafana Dashboard
      id: setup-grafana
      run: |
        # Get the public IP from the previous step output or set default
        PUBLIC_IP="${{ steps.get-env.outputs.stdout }}"
        if [[ "$PUBLIC_IP" == *"PUBLIC_IP="* ]]; then
          PUBLIC_IP=$(echo "$PUBLIC_IP" | grep "PUBLIC_IP=" | cut -d'=' -f2)
        fi
        
        # Set default if empty
        if [ -z "$PUBLIC_IP" ]; then
          echo "Using fallback method to get public IP"
          PUBLIC_IP="your-ec2-public-ip"  # You'll need to replace this
        fi
        
        PROMETHEUS_URL="http://$PUBLIC_IP:30000"
        
        echo "Using Prometheus URL: $PROMETHEUS_URL"
        
        # Create Grafana setup script
        cat > grafana_setup.sh << 'EOF'
        #!/bin/bash
        set -e
        
        GRAFANA_URL="https://mohdyousuf9059.grafana.net"
        GRAFANA_API_KEY="$1"
        PROMETHEUS_URL="$2"
        
        if [ -z "$GRAFANA_API_KEY" ] || [ -z "$PROMETHEUS_URL" ]; then
            echo "Usage: $0 <GRAFANA_API_KEY> <PROMETHEUS_URL>"
            echo "Received API Key: ${GRAFANA_API_KEY:0:10}..."
            echo "Received Prometheus URL: $PROMETHEUS_URL"
            exit 1
        fi
        
        echo "🚀 Setting up Grafana Dashboard..."
        
        # Function to make API calls with better error handling
        make_api_call() {
            local method=$1
            local endpoint=$2
            local data=$3
            
            local response
            if [ -n "$data" ]; then
                response=$(curl -s -w "HTTPSTATUS:%{http_code}" -X $method \
                    -H "Authorization: Bearer $GRAFANA_API_KEY" \
                    -H "Content-Type: application/json" \
                    -d "$data" \
                    "$GRAFANA_URL/api/$endpoint" 2>/dev/null || echo "HTTPSTATUS:000")
            else
                response=$(curl -s -w "HTTPSTATUS:%{http_code}" -X $method \
                    -H "Authorization: Bearer $GRAFANA_API_KEY" \
                    -H "Content-Type: application/json" \
                    "$GRAFANA_URL/api/$endpoint" 2>/dev/null || echo "HTTPSTATUS:000")
            fi
            
            local body=$(echo $response | sed -E 's/HTTPSTATUS\:[0-9]{3}$//')
            local status=$(echo $response | tr -d '\n' | sed -E 's/.*HTTPSTATUS:([0-9]{3})$/\1/')
            
            echo "Status: $status"
            echo "Response: $body"
            
            if [[ $status -ge 200 && $status -lt 300 ]]; then
                echo "$body"
            else
                echo "API call failed with status $status: $body" >&2
                return 1
            fi
        }
        
        # 1. Create/Update Prometheus Data Source
        echo "📊 Setting up Prometheus data source..."
        DATASOURCE_PAYLOAD=$(cat <<EOFDS
        {
          "name": "Portfolio-Prometheus",
          "type": "prometheus",
          "url": "$PROMETHEUS_URL",
          "access": "proxy",
          "isDefault": true,
          "basicAuth": false,
          "jsonData": {
            "httpMethod": "POST",
            "manageAlerts": true,
            "prometheusType": "Prometheus",
            "prometheusVersion": "2.40.0",
            "cacheLevel": "High",
            "disableMetricsLookup": false,
            "incrementalQuerying": false
          }
        }
        EOFDS
        )
        
        # Try to create data source
        echo "Creating data source..."
        DATASOURCE_RESPONSE=$(make_api_call "POST" "datasources" "$DATASOURCE_PAYLOAD" 2>/dev/null || echo "Data source creation failed")
        echo "Data source response: $DATASOURCE_RESPONSE"
        
        # Get existing data sources to find UID
        echo "Getting existing data sources..."
        EXISTING_DS=$(make_api_call "GET" "datasources" "" 2>/dev/null || echo "[]")
        DATASOURCE_UID=$(echo "$EXISTING_DS" | grep -o '"uid":"[^"]*".*"name":"Portfolio-Prometheus"' | cut -d'"' -f4 | head -1)
        
        if [ -z "$DATASOURCE_UID" ]; then
            DATASOURCE_UID="portfolio-prometheus"
            echo "Using default UID: $DATASOURCE_UID"
        else
            echo "Found existing data source UID: $DATASOURCE_UID"
        fi
        
        # 2. Create Portfolio Monitoring Dashboard (simplified)
        echo "📊 Creating Portfolio Dashboard..."
        DASHBOARD_PAYLOAD=$(cat <<EOFDASH
        {
          "dashboard": {
            "id": null,
            "title": "Portfolio Application Monitoring",
            "tags": ["portfolio", "kubernetes", "monitoring"],
            "timezone": "browser",
            "panels": [
              {
                "id": 1,
                "title": "Prometheus Status",
                "type": "stat",
                "targets": [
                  {
                    "expr": "up{job=\"prometheus\"}",
                    "refId": "A",
                    "datasource": {
                      "type": "prometheus",
                      "uid": "$DATASOURCE_UID"
                    }
                  }
                ],
                "gridPos": {"h": 8, "w": 12, "x": 0, "y": 0}
              },
              {
                "id": 2,
                "title": "Total Targets",
                "type": "stat",
                "targets": [
                  {
                    "expr": "count(up)",
                    "refId": "A",
                    "datasource": {
                      "type": "prometheus",
                      "uid": "$DATASOURCE_UID"
                    }
                  }
                ],
                "gridPos": {"h": 8, "w": 12, "x": 12, "y": 0}
              }
            ],
            "time": {"from": "now-1h", "to": "now"},
            "refresh": "30s",
            "schemaVersion": 39,
            "version": 0
          },
          "overwrite": true
        }
        EOFDASH
        )
        
        DASHBOARD_RESPONSE=$(make_api_call "POST" "dashboards/db" "$DASHBOARD_PAYLOAD" 2>/dev/null || echo "Dashboard creation failed")
        echo "Dashboard response: $DASHBOARD_RESPONSE"
        
        # Extract dashboard URL
        DASHBOARD_URL=$(echo "$DASHBOARD_RESPONSE" | grep -o '"url":"[^"]*"' | cut -d'"' -f4 | head -1)
        if [ -n "$DASHBOARD_URL" ]; then
            echo "✅ Portfolio Dashboard created successfully!"
            echo "🔗 Dashboard URL: $GRAFANA_URL$DASHBOARD_URL"
        else
            echo "⚠️  Dashboard creation may have failed, but continuing..."
        fi
        
        echo "🎉 Grafana setup completed!"
        echo "📊 Access your dashboards at: $GRAFANA_URL"
        EOF
        
        # Make script executable and run it
        chmod +x grafana_setup.sh
        ./grafana_setup.sh "${{ secrets.GRAFANA_API_KEY }}" "$PROMETHEUS_URL"

    # Configure AWS credentials for Lambda invocation
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_REGION }}

    # Send success notification via Lambda
    - name: Send Success Notification
      if: success()
      run: |
        # Get the actual public IP
        PUBLIC_IP=$(curl -s http://169.254.169.254/latest/meta-data/public-ipv4 || echo "unknown")
        PROMETHEUS_URL="http://$PUBLIC_IP:30000"
        
        # Create payload file
        cat > payload.json << EOF
        {
          "repository": "${{ github.repository }}",
          "commit_sha": "${{ github.sha }}",
          "branch": "${{ github.ref_name }}",
          "build_status": "success",
          "workflow_run_id": "${{ github.run_id }}",
          "actor": "${{ github.actor }}",
          "prometheus_url": "$PROMETHEUS_URL",
          "public_ip": "$PUBLIC_IP",
          "skooner_url": "http://$PUBLIC_IP:30123",
          "grafana_url": "https://mohdyousuf9059.grafana.net"
        }
        EOF
        
        # Invoke Lambda with file payload
        aws lambda invoke \
          --function-name portfolio-notification-lambda \
          --payload file://payload.json \
          --cli-binary-format raw-in-base64-out \
          response.json || echo "Lambda invocation failed"
        
        echo "Success notification sent via Lambda"
        cat response.json || echo "No response file"

    # Send failure notification via Lambda (if any step fails)
    - name: Send Failure Notification
      if: failure()
      run: |
        # Create payload file
        cat > payload.json << EOF
        {
          "repository": "${{ github.repository }}",
          "commit_sha": "${{ github.sha }}",
          "branch": "${{ github.ref_name }}",
          "build_status": "failure",
          "workflow_run_id": "${{ github.run_id }}",
          "actor": "${{ github.actor }}"
        }
        EOF
        
        # Invoke Lambda with file payload
        aws lambda invoke \
          --function-name portfolio-notification-lambda \
          --payload file://payload.json \
          --cli-binary-format raw-in-base64-out \
          response.json || echo "Lambda invocation failed"
        
        echo "Failure notification sent via Lambda"
        cat response.json || echo "No response file"
